# ejava
java learn

chapter one

    对象具有行为 状态 标识

        类描述具有相同特性和行为的对象的集合
        每一个对象都可以与其他对象区别开来，因为它们在内存中都有一个唯一的地址
        每个对象都有一个接口 接口确定了对某一特定对象所能发出的请求
        将对象看作服务提供者是一件伟大的简化工具

    对象实现的隐藏

        让客户端程序员无法触及他们不应该触及的部分
        允许类库设计者改变内部类路的工作方式而不必担心会影响到客户端
        public
        default
        protected 就类用户而言是private 但对于继承于此类但导出类或任何位于同一包内的类来说 可访问
        private

    代码复用是面向对象程序设计最了不起的优点之一

        通过继承产生新类型 其不仅包括现有类型的所有成员 更重要的是它复制了基类的接口

    产生差异的方法

        导出类中增加新方法
        改变现有基类的方法的行为 即覆盖overriding

    编译器不可能产生传统意义上的函数调用  前期绑定

        OOP程序直到运行时才知道确定代码的地址

        编译器确保被调用的方法存在 并对调用参数和返回值执行类型检查 但并不知道将被执行但确切代码
        为执行  后期绑定  java使用一小段代码来替代绝对地址调用 这段代码 使用 在对象中存储的信息来计算方法体的地址

    单根继承结构

        保证所有对象都具有某些功能
        使垃圾回收器的实现变得容易的多

    容器

        arraylist   选取较快  插入慢
        linkedlist  选取较慢  插入快

    参数化类型

         一个编译器可以自动定制作用于特定类型上的类

chapter two

    对象存储

    寄存器

    最快存储区域 位于处理器内部，但数量极其有限，按需分配，不能直接控制 也不能在程序中感觉到寄存器存在的任何迹象

    栈

    位于通用RAM中，通过 堆栈指针 可从处理器处活得直接支持，上移 释放内存 下移 分配内存 速度仅次于寄存器
    java系统程序必须知道在栈内所有项的确切生命周期 以便移动指针
    java对象引用存储此处

    堆

    通用内存池 存放所有java对象 不同于栈 编译器不需要知道存储的数据在堆里存活多长时间
    其存储分配和清理可能比用栈进行存储分配需要跟多的时间

    常量存储

    常量值通常直接存放在程序代码内部 其永远不会改变

    非RAM存储

    数据完全存活于程序之外 eg 流对象&持久化对象

    特例 基本类型

    不使用new创建 而是创建一个并非是应用的 '自动' 变量 直接存储值于栈中，故更加高效
    基本类型所占存储空间大小不依赖于机器硬件架构
    基本类型的包装器类使得可以在堆中创建非基本对象 bcsfild[1224488]
    java创建数组对象 实际上就是创建一个引用数组 其存储同对象之创建

    java永远不需要销毁对象

    java默认对基本类型数据成员进行初始化 但不适用于局部变量

    方法名和参数列表 合起来称为 方法签名 唯一地标识出某个方法 方法只能作为类的一部分创建 其只能通过对象被调用 切该对象能够执行该方法

    java参数传递实际上是传递引用 return 首先代表该方法已经做完，可以离开，其次如果产生返回值 则于其后

    java static 标识该域或方法不会于包含它的那个类的任何实例对象关联 故未创建类对象时也可以调用

        使用类名引用static变量 不仅强调了其static结构 且在某些情况下还为编译器优化提供了更好的机会

chapter three

    java 操作符

    几乎所有操作符都只能操作基本类型
    = == != 可操作所有对象
    String类支持+和+= 编译器会将+后所跟非String类型元素转化为String
    基本数据类型赋值 是直接复制内容
    对象赋值 是直接传递引用

    测试对象等价性 需区分基本数据类型和对象类型及自定义类型

    java中不可将非布尔值当作布尔值参与逻辑表达式运算 如果String后跟布尔值 则自动转换成对应文本

    短路 java中一旦能够明确无误地确定整个表达式的值 就不再计算其余下部分

    位运算 操作整数基本数据类型中的单个bit 即二进制位

    & 两个bit均为1 输出1
    | 两个bit只要有一个为1 输出1
    ^ 两个bit不同 输出1 同 输出0
    ～ 取反

    位移

    << 左移 低位补0
    >> 右移 有符号位 为正 则高位插入0 为负 则高位插入1
    >>> 无符号右移 无论正负 高位插入0
    byte char short 移位之前会被转换为int类型 且右端低5位才有用
    long 右端低6位才有用

    截尾和舍入[round]


chapter four

    else if 并非新的关键字
    return 一指定返回值 而退出当前方法并返回值
    如果在void方法中没有return 那么会默认存在一个隐式return
    break 退出当前循环
    continue 停止执行当前的迭代 退回循环起始处 开始下一次迭代

chapter five

    java 通过构造器确保初始化进行 由于构造器名称必须与类名完全相同 故方法首字母小写风格不适用于构造器
    java 默认针对没有构造器的类 创建默认构造器；如果已经定义 则不会自动创建
    this 只能在方法内部使用 标识 '调用方法的那个对象' 的引用

    static方法就是没有this的方法

    java中对象并非总是被垃圾回收
      1，对象可能不被回收
      2，垃圾回收并不等于析构
      3，垃圾回收只与内存有关

    在类内部 变量定义的顺序先后决定类初始化的顺序
    静态初始化只有在必要时才会进行

chapter seven

    初始化引用位置
        1，在定义的地方 此处意味总能够在构造器被调用之前被初始化
        2，在类的构造器中
        3，在正要使用这些对象之前 亦称 惰性初始化
        4，使用实例初始化

    组合
        将一个成员对象置于所要构建的类中 将现有类作为新类的底层实现

        当想在新类中使用现有类的功能而非其接口的情形适用于组合
        在新类中嵌入现有类对象，让其实现新类所需的功能，但新类的用户看到的只是为新类定义的接口，而非嵌入对象的接口
        通常声明该嵌入类对象为private成员

        当然 有时可以允许用户直接访问新类中的嵌入类成员

    继承 is-a新类是现有类的一种类型 复用现有类的接口
        1，基类所有的数据成员都指定为 private
        2，基类所有的方法都指定为 public
        3，导出类包含有基类的子对象

        当新类需要向上转型时 继承是必要的；如果不需要 则需慎重考虑

    代理  组合和继承的中庸之道
        1，于构造类中放置他类对象成员
        2，同时于代理类中暴露该成员对象的所有方法

    如果需要进行清理 最好是编写自己的清理方法 但不要使用finalize()

    final 无法改变 通常出于设计和效率的考虑

        final数据

        在java中该类常量必须是基本数据类型 且其使用时 必须初始化
        一个既是static又是final的域只占据一段不能改变的存储空间
        final对象 其引用恒定不变 无法再指向另一个对象 但对象自身是可被修改的
        final参数 意味着无法在方法中更改引用所指向的对象

        final方法

        类中所有的private方法都被隐式的指定为final
        出于设计：在继承中不能被覆盖
        出于效率：一般不需要

        final类

        不允许继承


chapter eight

    多态 是OOP中继 数据抽象 继承 之后的第三种基本特征
    多态 通过分离做什么 和 怎么做 从另一角度将接口和实现分离开来，多态不但能够改造代码的组织结构和可读性
        还能通过创建可扩展的程序----无论项目创建 还是 需要添加新功能时都可以生长的程序
        其作用是消除类型之间的耦合关系
        其方法调用允许一种类型表现出与其他相似类型之间的区别，只要他们源自同一基类
    绑定 将一个方法调用同一个方法主体关联起来

    多态 将改变的事物 与 未变的事物分离开来

        在运行时根据对象类型进行绑定 称作 后期绑定 动态绑定 运行时绑定
        java中除static方法和final方法 都是后期绑定 且 自动发生

        java的继承只能覆盖非private方法
        向上转型时 任何域访问操作都讲由编译器解析 因此不是多态的

        java不具有多态性 其都是隐式声明的static方法

    初始化实际过程
        1，在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零
        2，调用基类构造器，该过程会反复递归：首先是构造这种层次的根 然后是下一层导出类，直到最底层导出类
        3，按声明顺序调用成员的初始化方法
        4，调用导出类构造器主体
    构造器准则
        用尽可能简单的方法使对象进入正常状态，如果可以的话 避免调用其他方法

    再谈组合&继承
        首先对现有类对使用 如果首先考虑使用继承技术 反倒会加重设计负担
        其次更好的首选是使用组合 尤其是不能十分确定应该使用哪一种方式时
        再次组合不会强制程序设计进入继承的层次结构中
        第四组合更加灵活 它可以动态选择类型，也就选择了行为，而继承在编译时就需要知道确切类型

    用继承表达行为间的差异 并用字段表达状态上的变化

    RTTI Run Time Type Identify




