# ejava
java learn

chapter one

    对象具有行为 状态 标识

        类描述具有相同特性和行为的对象的集合
        每一个对象都可以与其他对象区别开来，因为它们在内存中都有一个唯一的地址
        每个对象都有一个接口 接口确定了对某一特定对象所能发出的请求
        将对象看作服务提供者是一件伟大的简化工具

    对象实现的隐藏

        让客户端程序员无法触及他们不应该触及的部分
        允许类库设计者改变内部类路的工作方式而不必担心会影响到客户端
        public
        default
        protected 就类用户而言是private 但对于继承于此类但导出类或任何位于同一包内的类来说 可访问
        private

    代码复用是面向对象程序设计最了不起的优点之一

        通过继承产生新类型 其不仅包括现有类型的所有成员 更重要的是它复制了基类的接口

    产生差异的方法

        导出类中增加新方法
        改变现有基类的方法的行为 即覆盖overriding

    编译器不可能产生传统意义上的函数调用  前期绑定

        OOP程序直到运行时才知道确定代码的地址

        编译器确保被调用的方法存在 并对调用参数和返回值执行类型检查 但并不知道将被执行但确切代码
        为执行  后期绑定  java使用一小段代码来替代绝对地址调用 这段代码 使用 在对象中存储的信息来计算方法体的地址

    单根继承结构

        保证所有对象都具有某些功能
        使垃圾回收器的实现变得容易的多

    容器

        arraylist   选取较快  插入慢
        linkedlist  选取较慢  插入快

    参数化类型

         一个编译器可以自动定制作用于特定类型上的类

chapter two

    对象存储

    寄存器

    最快存储区域 位于处理器内部，但数量极其有限，按需分配，不能直接控制 也不能在程序中感觉到寄存器存在的任何迹象

    栈

    位于通用RAM中，通过 堆栈指针 可从处理器处活得直接支持，上移 释放内存 下移 分配内存 速度仅次于寄存器
    java系统程序必须知道在栈内所有项的确切生命周期 以便移动指针
    java对象引用存储此处

    堆

    通用内存池 存放所有java对象 不同于栈 编译器不需要知道存储的数据在堆里存活多长时间
    其存储分配和清理可能比用栈进行存储分配需要跟多的时间

    常量存储

    常量值通常直接存放在程序代码内部 其永远不会改变

    非RAM存储

    数据完全存活于程序之外 eg 流对象&持久化对象

    特例 基本类型

    不使用new创建 而是创建一个并非是应用的 '自动' 变量 直接存储值于栈中，故更加高效
    基本类型所占存储空间大小不依赖于机器硬件架构
    基本类型的包装器类使得可以在堆中创建非基本对象 bcsfild[1224488]
    java创建数组对象 实际上就是创建一个引用数组 其存储同对象之创建

    java永远不需要销毁对象

    java默认对基本类型数据成员进行初始化 但不适用于局部变量

    方法名和参数列表 合起来称为 方法签名 唯一地标识出某个方法 方法只能作为类的一部分创建 其只能通过对象被调用 切该对象能够执行该方法

    java参数传递实际上是传递引用 return 首先代表该方法已经做完，可以离开，其次如果产生返回值 则于其后

    java static 标识该域或方法不会于包含它的那个类的任何实例对象关联 故未创建类对象时也可以调用

        使用类名引用static变量 不仅强调了其static结构 且在某些情况下还为编译器优化提供了更好的机会

chapter three

    java 操作符

    几乎所有操作符都只能操作基本类型
    = == != 可操作所有对象
    String类支持+和+= 编译器会将+后所跟非String类型元素转化为String
    基本数据类型赋值 是直接复制内容
    对象赋值 是直接传递引用

    测试对象等价性 需区分基本数据类型和对象类型及自定义类型

    java中不可将非布尔值当作布尔值参与逻辑表达式运算 如果String后跟布尔值 则自动转换成对应文本

    短路 java中一旦能够明确无误地确定整个表达式的值 就不再计算其余下部分

    位运算 操作整数基本数据类型中的单个bit 即二进制位

    & 两个bit均为1 输出1
    | 两个bit只要有一个为1 输出1
    ^ 两个bit不同 输出1 同 输出0
    ～ 取反

    位移

    << 左移 低位补0
    >> 右移 有符号位 为正 则高位插入0 为负 则高位插入1
    >>> 无符号右移 无论正负 高位插入0
    byte char short 移位之前会被转换为int类型 且右端低5位才有用
    long 右端低6位才有用

    截尾和舍入[round]


chapter four

    else if 并非新的关键字
    return 一指定返回值 而退出当前方法并返回值
    如果在void方法中没有return 那么会默认存在一个隐式return
    break 退出当前循环
    continue 停止执行当前的迭代 退回循环起始处 开始下一次迭代

chapter five

    java 通过构造器确保初始化进行 由于构造器名称必须与类名完全相同 故方法首字母小写风格不适用于构造器
    java 默认针对没有构造器的类 创建默认构造器；如果已经定义 则不会自动创建
    this 只能在方法内部使用 标识 '调用方法的那个对象' 的引用

    static方法就是没有this的方法

    java中对象并非总是被垃圾回收
      1，对象可能不被回收
      2，垃圾回收并不等于析构
      3，垃圾回收只与内存有关

    在类内部 变量定义的顺序先后决定类初始化的顺序
    静态初始化只有在必要时才会进行

chapter seven

    初始化引用位置
        1，在定义的地方 此处意味总能够在构造器被调用之前被初始化
        2，在类的构造器中
        3，在正要使用这些对象之前 亦称 惰性初始化
        4，使用实例初始化

    组合
        将一个成员对象置于所要构建的类中 将现有类作为新类的底层实现

        当想在新类中使用现有类的功能而非其接口的情形适用于组合
        在新类中嵌入现有类对象，让其实现新类所需的功能，但新类的用户看到的只是为新类定义的接口，而非嵌入对象的接口
        通常声明该嵌入类对象为private成员

        当然 有时可以允许用户直接访问新类中的嵌入类成员

    继承 is-a新类是现有类的一种类型 复用现有类的接口
        1，基类所有的数据成员都指定为 private
        2，基类所有的方法都指定为 public
        3，导出类包含有基类的子对象

        当新类需要向上转型时 继承是必要的；如果不需要 则需慎重考虑

    代理  组合和继承的中庸之道
        1，于构造类中放置他类对象成员
        2，同时于代理类中暴露该成员对象的所有方法

    如果需要进行清理 最好是编写自己的清理方法 但不要使用finalize()

    final 无法改变 通常出于设计和效率的考虑

        final数据

        在java中该类常量必须是基本数据类型 且其使用时 必须初始化
        一个既是static又是final的域只占据一段不能改变的存储空间
        final对象 其引用恒定不变 无法再指向另一个对象 但对象自身是可被修改的
        final参数 意味着无法在方法中更改引用所指向的对象

        final方法

        类中所有的private方法都被隐式的指定为final
        出于设计：在继承中不能被覆盖
        出于效率：一般不需要

        final类

        不允许继承




